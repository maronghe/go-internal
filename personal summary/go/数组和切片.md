> 数组和切片的区别



1. 底层结构
2. 创建
   1. var
   2. make
   3. []int{}
3. slice扩容
4. 复用底层数组



注意：

1. array不能跟nil比较，编译报错
2. make只能用于 map， channel ，slice的创建，不能创建数组
3. var arr [5]int 创建数组，初始化为5个零



​	

1. 数组大小不可变，切片可变
2.  kind 
   1. 数组 array [2]int , [3]int[]
   2. slice  slice  []int
3. copy 仅能用于slice，并且dst必须要有容量
4. 复用底部数组 t3 := t1[2:4] // 左闭右开
5. 创建 
   1. var arr []int // arr == nil  true 
   2. make &  []int{} // arr != nil  true



```go

	arr := [2]int{1, 3}
	fmt.Println(reflect.ValueOf(arr).Kind()) // array
	fmt.Println(reflect.ValueOf(arr).Type()) // [2]int

	s1 := []int{1, 3}
	fmt.Println(reflect.ValueOf(s1).Kind()) // slice
	fmt.Println(reflect.ValueOf(s1).Type()) // []int

```



slice的扩容规则三步走
1. 计算预估容量大小 ： 如果预估扩容后的slice的容量大于原来的容量的2倍，则预估容量为扩容后的大小。
    例如： 

  ```go
  arr := []int{1,2}
  arr = append(arr, []int{3,4,5}...)
  ```

  1. 原slice容量为2，扩容后为5 > 4。那么预估容量为5。
  2. 若上述不成立，若扩容后的容量大小小于原数组的2倍
     1. 若 原来容量小于1024，则扩容翻倍  -> 2 * oldCap
     2. 若 原来容量大等于1024，则扩容四分之一 -> 1.25 * oldCap

2. 计算扩容后需要占用的内存大小：元素大小有关，在64位机器下int为8字节

   ```go
   8 * 5 = 40 // 需要40字节
   ```

3. 计算最终容量大小：

   go采用的是基于tcmalloc进行的内存分配，也就是go语言自己实现的内存分配器。

   其内存分配规则如下

   ```go
   // 内存 划分
   var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768}
   
   //runtime下sizeclasses.go文件
   ```

   扩容时若步骤2需要40字节大小的slice，那么内存分配器不会给40字节，而是选择大等于40字节，并最接近的大小的48字节。

   即

   ```go
   48 / 8(int 64位下占用的大小) = 6 
   ```

   则扩容后的容量为 6 